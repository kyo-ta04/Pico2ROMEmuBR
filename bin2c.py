#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import argparse

def generate_c_source(input_file, output_base, array_name):
    """
    Reads a binary file and generates a C source and header file.

    :param input_file: Path to the input binary file.
    :param output_base: Base name for the output .c and .h files.
    :param array_name: Name for the C array variable.
    """
    c_file_path = output_base + '.c'
    h_file_path = output_base + '.h'

    try:
        with open(input_file, 'rb') as f:
            binary_data = f.read()
    except FileNotFoundError:
        print(f"Error: Input file not found at '{input_file}'")
        return

    # --- Generate C source file (.c) ---
    with open(c_file_path, 'w') as f:
        f.write(f'/* Auto-generated by bin2c.py from {os.path.basename(input_file)} */\n\n')
        f.write(f'#include \"{os.path.basename(h_file_path)}\"\n\n')
        f.write(f'const unsigned char {array_name}[] = {{\n')

        for i in range(0, len(binary_data), 16):
            chunk = binary_data[i:i+16]
            hex_values = [f'0x{byte:02x}' for byte in chunk]
            line = "    " + ", ".join(hex_values)

            # Add trailing comma if it\'s not the last byte overall
            if i + len(chunk) < len(binary_data):
                line += ','

            # Pad to align comments
            padding_target = 84
            if len(line) < padding_target:
                line += ' ' * (padding_target - len(line))

            line += f'// 0x{i:04x}\n'
            f.write(line)

        f.write('};\n\n')
        f.write(f'const unsigned int {array_name}_size = sizeof({array_name});\n')

    # --- Generate C header file (.h) ---
    guard_name = os.path.basename(h_file_path).upper().replace('.', '_')
    with open(h_file_path, 'w') as f:
        f.write(f'/* Auto-generated by bin2c.py from {os.path.basename(input_file)} */\n\n')
        f.write(f'#ifndef {guard_name}\n')
        f.write(f'#define {guard_name}\n\n')
        f.write('#include <stdio.h>\n\n')
        f.write(f'extern const unsigned char {array_name}[];\n')
        f.write(f'extern const unsigned int {array_name}_size;\n\n')
        f.write(f'#endif /* {guard_name} */\n')

    print(f"Successfully generated:\n  - {c_file_path}\n  - {h_file_path}")


def main():
    """ Main function """
    parser = argparse.ArgumentParser(
        description='Convert a binary file to a C source and header file.',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        'input_file', 
        type=str, 
        help='Path to the input binary file.'
    )
    parser.add_argument(
        '-o', '--output', 
        type=str, 
        help='Base name for the output .c and .h files.\n(e.g., -o my_rom)\nIf not provided, it is derived from the input file name.'
    )
    parser.add_argument(
        '-n', '--name', 
        type=str, 
        help='Variable name for the C array.\n(e.g., -n my_rom_data)\nIf not provided, it is derived from the output base name.'
    )

    args = parser.parse_args()

    # Determine output base name
    if args.output:
        output_base = args.output
    else:
        output_base, _ = os.path.splitext(args.input_file)

    # Determine array name
    if args.name:
        array_name = args.name
    else:
        array_name = os.path.basename(output_base)

    generate_c_source(args.input_file, output_base, array_name)

if __name__ == '__main__':
    main()
